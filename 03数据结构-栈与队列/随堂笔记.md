栈：数据结构里的栈，图

内存里的堆栈：我们可以理解为：真实存在的物理内存区域

堆栈：逻辑

栈：是一种受限制的限制表，LIFO(后进先出)

入栈、出栈

javascript的调用栈（执行栈）

全局执行上下文、函数执行上下文、Eval

调用帧

尾调用：一个函数的最后一步是调用另外一个函数

尾递归：尾调用自身，尾递归

递归非常耗费内存的，因为它需要同时保存很多个调用帧，尾递归：它只存在一个调用帧，所以它是不会发生栈溢出错误的

队列：

JS的运行机制

队列，（queue），它是一种一种运算受限的线性表，FIFO（先进先出）

栈：后进先出

受限之处：它只允许表的前端进行删除操作，在表的后端进行增加操作

面对无法同时处理多个请求的场景，我们通常就会使用队列，先进先出，一个一个的解决问题，保证有序

JS的异步队列

javascript：单线程，同一个时间只能做一件事。

线程是最小的执行单元，进程是最小的资源管理单元

打开一个游戏，打开一个软件的同时，你就开启了一个进程（进程是大哥）

线程是从属于进程，在软件运行的过程里边（在这个进程）

进程是大哥，线程是小弟（进程大哥管着线程小弟）

JS：要设计成单线程

JS的单线程，与它的用途有关

JS的主要作用：完成与用户交互，以及DOM操作。

一个线程在一个DOM上添加了内容，另外一个线程又删除了这个DO节点

避免复杂性，从一开始，JS就是单线程，在未来也不会改变

H5 ，web worker 标准，它是允许JS 创建多个线程，但是，子线程是完全受主线程控制的，而且子线程是不可以操作DOM的。

单线程：所有的任务需要排队，前一个任务结束了以后，才能执行下一个任务。

如果：前一个任务耗时很长，发起一个请求，网络很慢，后面的那个任务是不是就要一直等着。

沈腾（买电影票）

IO的时候，（输入输出的时候），主线程不去管IO，挂起处于等待中的任务，先运行排在后面的任务，等待IO设备返回了结果，再回过头，把挂起等待的任务继续执行下去。于是所有的任务：同步任务，异步任务

同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕以后，才能够去执行下一个任务。

异步任务：不进入主线程，而是进入“任务队列”，只有“任务队列”通知主线程，某个异步任务可以执行了，这个任务才会进入主线程执行。

同步会阻塞后面的代码，

等

异步任务：

等待0秒，主线程一有空，就立即执行，不是等待0秒

JS里边，哪些是同步的，哪些是异步的

定时器、ajax、事件 （异步的）

~~~js
console.log(1);
setTimeout(() => {
  console.log(2);
}, 50);
setTimeout(() => {
  console.log(3);
}, 0);
console.log(4);

~~~

1.最先执行的是：同步代码，执行完毕以后，立即出栈，让出主线程

2.同步代码执行完毕，立即出栈，此时主线程是出于：空闲状态

主线程去读取任务队列，队列遵循的原则是先进先出，但是，有个条件，触发条件相等，会遵循先进先出，如果触发条件不相同，则优先执行到达触发条件的代码，等待0秒不是，主线程一有空就立即执行

主线程里边维护着一个任务队列，这个任务保存的是：异步的代码

JS是单线程语言，浏览器只会分配一个主线程给JS，用来执行任务（函数）

但是一次只能执行一个任务。



1.所有的同步任务都是在主线程上执行，形成一个执行栈

2.主线程之外，还存在一个任务队列，只要存在异步任务，就会在任务队列里放置一个事件

3.一旦执行栈里边同步任务代码执行完毕，主线程就会去读取“任务队列”，看任务队列有哪些对应的异步任务，结束等待状态，进入执行栈，开始执行

主线程不断重复上面3个步骤

主线程执行完毕以后，从事件队列中去读取任务队列的过程，我们称之为事件循环（Event Loop）

ajax去请求网络，回调地狱



~~~js
$.ajax({
  url:'url',
  dataType:'json',
  success:function (res){
    $.ajax({
      url:'url',
     	success:function(res) {
        
      }
    })
  }
})
~~~

任务队列：存在着两个队列，一个是宏任务队列，一个是微任务队列

//  主线程：同步任务->微任务->宏任务

I/O，定时器、事件绑定、ajax ...存在于宏任务队列里的

Promise.then catch finally process.nextTick 都是存在微任务队列



