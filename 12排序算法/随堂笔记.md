## 前端与算法

前端对于算法没有那么重要。JS在计算方面，它并不是你那么擅长。在前端进行大量的计算本身就是不合理的。

大数据可视化。前端学习算法是为了构造我们的编程思维。

## 1. 冒泡排序

冒泡排序是**升序排列**，有点像小鱼去吐气泡，大的在上面，小的在下面

冒泡排序的核心思想是：让数组的当前项和后一项进行比较，如果当前项比后一项大，就交换位置（大的在后面，小的在前面）

~~~js
const arr = [12,8,24,16,1] // 对它进行升序排序 1 8 12 16 24
~~~

1. 第一轮：比较4次（不用跟自己比较）
2. 第二轮：比较3次（最大值和自己不用比较）
3. 每一轮的比较我们都把当前的最大值放到了数组的末尾，所以当前轮比较多少，需要把之前放到末尾的值去掉

冒泡排序的时间复杂度：最坏的情况是：倒序，一共要进行n -1 次循环

~~~ 
(n-1)+(n-2)+(n-3)... + 1 = n*(n-1)/2 
~~~

时间复杂度：O(n<sup>2</sup>)

冒泡排序的空间复杂度：交换元素的时候那个临时变量所占的内存空间，O(n) ，O(1)

## 2.选择排序

选择排序的思路是：选定第一个索引的位置，然后和后面的元素依次比较，如果后面的元素小于第一个元素的索引，就交换位置。经过一轮比较以后，可以确定第一个位置是最小的

选择排序：第一轮会选出最小值，第二轮选出第二小的值，依次类推...

首先从数组里边找到最小的元素，并且把最小的元素放在数组的最前面，然后再从剩下的元素中去第二小的值，放在最小的元素的后面，直到排序完毕

选择排序时间复杂度：O(n<sup>2</sup>)

## 3 插入排序

插入排序是简单排序（冒泡，选择，插入排序），效率最高的是插入排序。

1. 从第一个元素开始，这个元素可以认为已经被排序（下标是1开始，0 这个位置默认已经被排序）
2. 取出下一个元素，已经排序的元素中，从后面向前遍历
3. 如果说这个元素大于新的元素，就将这个元素移到下一个位置
4. 重复上一个步骤，直到找到已经排序的元素小于或者等于新元素的位置
5. 将新元素插入到这个位置以后，重复上面的步骤

## 4 希尔排序

希尔排序的本质是一种插入排序，但是它对数组进行了等间隔的分组处理，在每一组中做插入排序。

O(n<sup>2</sup>) => O(nlogn)

O(1) <  O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) <  O(2<sup>n</sup>)

希尔排序是按一定的间隔对数组进行分组，然后在每一个分组中做插入排序；随后逐次缩小间隔，在每一个分组中进行插入排序，直到间隔等于1，做一次插入排序后结束

第一次排序的时候，每一组较小的元素都移动到了相对靠前位置

## 5 归并排序

拆分和归并

分治

思路：如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分结合再一起。归并排序的核心思想就排序和合并两个有序数组。

1. 将数组拆分称两个数组，然后对数组各自进行排序
2. 合并两个已经排序好的数组

## 6 快速排序

分治法：

将原本的问题分解成若干个规模更小但解构与原来的问题相似的子问题，递归解决子问题，然后将这些子问题进行合并

快速排序：

1. 选择一个元素作为基准（pivot）

   所有小于基准的元素，都移动到（基准）左边，所有大于基准的元素都移动（基准）右边，分区操作结束完毕以后，基准元素所处的问题就是最终排序后的位置

2. 对基准的左边和右边的两个子集，不断重复第一步和第二步直到所有的元素只剩一个为止

